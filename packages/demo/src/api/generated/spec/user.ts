/**
 * Generated by orval v6.17.0 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.6
 */
import useSwr from "swr";
import type { SWRConfiguration, Key } from "swr";
import type { UserArrayBody, User, LoginUserParams } from "../model";
import { fetchTransit } from "../../fetch-transit";
import type { ErrorType, BodyType } from "../../fetch-transit";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithArrayInput = (
  userArrayBody: BodyType<UserArrayBody>
) => {
  return fetchTransit<void>({
    url: `/user/createWithArray`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: userArrayBody,
  });
};

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithListInput = (
  userArrayBody: BodyType<UserArrayBody>
) => {
  return fetchTransit<void>({
    url: `/user/createWithList`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: userArrayBody,
  });
};

/**
 * @summary Get user by user name
 */
export const getUserByName = (username: string) => {
  return fetchTransit<User>({ url: `/user/${username}`, method: "get" });
};

export const getGetUserByNameKey = (username: string) =>
  [`/user/${username}`] as const;

export type GetUserByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserByName>>
>;
export type GetUserByNameQueryError = ErrorType<void>;

/**
 * @summary Get user by user name
 */
export const useGetUserByName = <TError = ErrorType<void>>(
  username: string,
  options?: {
    swr?: SWRConfiguration<
      Awaited<ReturnType<typeof getUserByName>>,
      TError
    > & { swrKey?: Key; enabled?: boolean };
  }
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false && !!username;
  const swrKey =
    swrOptions?.swrKey ??
    (() => (isEnabled ? getGetUserByNameKey(username) : null));
  const swrFn = () => getUserByName(username);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export const updateUser = (username: string, user: BodyType<User>) => {
  return fetchTransit<unknown>({
    url: `/user/${username}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: user,
  });
};

/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export const deleteUser = (username: string) => {
  return fetchTransit<unknown>({ url: `/user/${username}`, method: "delete" });
};

/**
 * @summary Logs user into the system
 */
export const loginUser = (params: LoginUserParams) => {
  return fetchTransit<string>({ url: `/user/login`, method: "get", params });
};

export const getLoginUserKey = (params: LoginUserParams) =>
  [`/user/login`, ...(params ? [params] : [])] as const;

export type LoginUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof loginUser>>
>;
export type LoginUserQueryError = ErrorType<void>;

/**
 * @summary Logs user into the system
 */
export const useLoginUser = <TError = ErrorType<void>>(
  params: LoginUserParams,
  options?: {
    swr?: SWRConfiguration<Awaited<ReturnType<typeof loginUser>>, TError> & {
      swrKey?: Key;
      enabled?: boolean;
    };
  }
) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getLoginUserKey(params) : null));
  const swrFn = () => loginUser(params);

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * @summary Logs out current logged in user session
 */
export const logoutUser = () => {
  return fetchTransit<void>({ url: `/user/logout`, method: "get" });
};

export const getLogoutUserKey = () => [`/user/logout`] as const;

export type LogoutUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof logoutUser>>
>;
export type LogoutUserQueryError = ErrorType<void>;

/**
 * @summary Logs out current logged in user session
 */
export const useLogoutUser = <TError = ErrorType<void>>(options?: {
  swr?: SWRConfiguration<Awaited<ReturnType<typeof logoutUser>>, TError> & {
    swrKey?: Key;
    enabled?: boolean;
  };
}) => {
  const { swr: swrOptions } = options ?? {};

  const isEnabled = swrOptions?.enabled !== false;
  const swrKey =
    swrOptions?.swrKey ?? (() => (isEnabled ? getLogoutUserKey() : null));
  const swrFn = () => logoutUser();

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(
    swrKey,
    swrFn,
    swrOptions
  );

  return {
    swrKey,
    ...query,
  };
};

/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export const createUser = (user: BodyType<User>) => {
  return fetchTransit<void>({
    url: `/user`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: user,
  });
};
